; nasm -felf64 inf2baaN3148.S && gcc -static -o inf2baaN3149 inf2baaN3149.o

extern printf
extern sscanf

section .note.GNU-stack noalloc noexec

section .data
    result dw 0                ; Объявляем переменную result как слово (2 байта) и инициализируем нулем.
    format db "%hu", 0         ; Форматная строка для sscanf, "%hu" ожидает беззнаковое короткое целое (unsigned short).
    result_out db "Преобразованное число: %hu", 10, 0 ; Строка для вывода преобразованного числа, %hu - беззнаковое короткое целое, 10 - символ новой строки.
    result_in db "Исходное число: %hu", 10, 0    ; Строка для вывода исходного числа.
    error_msg db 'Ошибка: программа принимает только один аргумент.', 10 ; Сообщение об ошибке при неправильном количестве аргументов.
    error_msg_len equ $ - error_msg ; Вычисляем длину сообщения об ошибке.
    bin_f db "%c", 0         ; Форматная строка для printf при выводе двоичного представления, %c - символ.
    len dw 0                    ; Переменная для хранения количества выведенных битов (используется в printb).
    return_button db 10, 0      ; Символ новой строки для форматирования вывода.
    error_not_digit db 'Ошибка: введенный аргумент не является числом. (или вне нужного диапазона)', 10 ; Сообщение об ошибке, если аргумент не является числом.
    error_not_digit_len equ $ - error_not_digit ; Длина сообщения об ошибке.
    error_out_of_range db 'Ошибка: число вне допустимого диапазона (0-65535).', 10 ; Сообщение об ошибке, если число вне диапазона.

section .bss
    number resb 8              ; Резервируем 8 байт для хранения строки аргумента.
    argc resb 8                ; Резервируем 8 байт для хранения количества аргументов (argc).
    argv resb 8                ; Резервируем 8 байт для хранения указателя на массив аргументов (argv).

section .text
    global main

main:
    push rbp                    ; Сохраняем значение регистра rbp (base pointer) на стеке.
    mov rbp, rsp                ; Устанавливаем rbp на текущее значение rsp (stack pointer).

    mov [argc], rdi             ; Копируем значение argc (количество аргументов) из регистра rdi в нашу переменную argc.
    mov [argv], rsi             ; Копируем значение argv (указатель на массив аргументов) из регистра rsi в нашу переменную argv.

    cmp qword [argc], 2         ; Сравниваем количество аргументов с 2 (имя программы + один аргумент).
    jg error_more_than_1_arg   ; Если аргументов больше 2, переходим к обработке ошибки.

    cmp qword [argc], 2         ; Снова сравниваем количество аргументов с 2.
    jb randnum                  ; Если аргументов меньше 2 (только имя программы), переходим к генерации случайного числа.

    mov rax, [argv]             ; Загружаем адрес массива argv в rax.
    lea rdx, [rax+8]            ; Вычисляем адрес второго элемента массива argv (первого аргумента командной строки).
    mov rdx, [rdx]              ; Загружаем сам указатель на строку аргумента из памяти по вычисленному адресу.
    mov [number], rdx           ; Сохраняем указатель на строку аргумента в нашу переменную number.

    push rbx                    ; Сохраняем регистры, которые будем использовать, на стеке.
    push rdx
    push rax
    push rsi

    mov rsi, [rsp + 16]         ; Восстанавливаем указатель на строку аргумента из стека.
    call is_digit               ; Вызываем функцию проверки, является ли аргумент числом.
    cmp rax, 1                  ; Проверяем возвращаемое значение функции is_digit (0 - число, 1 - не число).
    je error_not_a_digit_arg   ; Если не число, переходим к обработке ошибки.

    mov rsi, [rsp + 16]         ; Снова восстанавливаем указатель на строку аргумента из стека.
    call is_correct_range      ; Вызываем функцию проверки диапазона числа.
    cmp rax, 1                  ; Проверяем возвращаемое значение функции is_correct_range (0 - в диапазоне, 1 - вне диапазона).
    je error_out_of_range_arg   ; Если вне диапазона, переходим к обработке ошибки.

    pop rbx                     ; Восстанавливаем сохраненные регистры из стека.
    pop rdx
    pop rax
    pop rsi

    ; Вызвать функцию sscanf
    mov rdi, [number]           ; Первый аргумент для sscanf - указатель на строку с числом.
    mov rsi, format             ; Второй аргумент - форматная строка "%hu".
    lea rdx, [result]           ; Третий аргумент - адрес, куда будет записан результат преобразования.
    call sscanf                 ; Вызываем функцию sscanf для преобразования строки в число.

Lb1:
    ; Вывод исходного числа в десятичном виде
    mov rdi, result_in          ; Загружаем адрес строки "Исходное число: "
    movzx rsi, word [result]    ; Загружаем беззнаковое слово из переменной result в rsi для printf.
    call printf                 ; Выводим строку и исходное число.

    ; Вывод исходного числа в двоичном виде
    movzx rdi, word [result]    ; Передаем исходное число в printb
    call printb                 ; Выводим двоичное представление исходного числа.

    mov ax, [result]            ; Загружаем 16-битное число из переменной result в регистр ax.
    call shift_tetrad           ; Вызываем функцию shift_tetrad для обработки числа.
    mov [result], ax            ; Сохраняем обработанное число из регистра ax обратно в переменную result.

    ; Вывод преобразованного числа в десятичном виде
    mov rdi, result_out         ; Загружаем адрес строки "Преобразованное число: "
    movzx rsi, word [result]    ; Загружаем беззнаковое слово из переменной result в rsi для printf.
    call printf                 ; Выводим строку и преобразованное число.

    ; Вывод преобразованного числа в двоичном виде
    movzx rdi, word [result]    ; Передаем преобразованное число в printb
    call printb                 ; Выводим двоичное представление преобразованного числа.

    mov rsp, rbp                ; Восстанавливаем регистр rsp.
    pop rbp                     ; Восстанавливаем регистр rbp.
    xor rax, rax                ; Устанавливаем код возврата в 0.
    ret                         ; Выход из программы.

shift_tetrad:
    push rbx
    push rcx
    push rdx
    push rsi

    mov bx, ax       ; Сохраняем исходное значение
    mov si, ax       ; Копия для восстановления

    ; Обработка младшего байта (bl)
    mov al, bl       ; al = младший байт
    push cx          ; Сохраняем cx перед изменением
    mov cl, al
    shr cl, 6        ; cl = биты 6-7 (старшая тетрада)
    and cl, 0x03     ; cl = количество сдвигов (0-3)
    mov dl, al
    and dl, 0x0F     ; dl = младшая тетрада
    mov bl, 0        ; Флаг переноса

    ; Циклический сдвиг младшей тетрады
    test cl, cl
    jz lower_done    ; Если сдвиг 0, пропускаем цикл

lower_shift:
    test bl, bl
    jz no_carry_lower
    or dl, 0x01      ; Добавляем перенос
    mov bl, 0

no_carry_lower:
    test dl, 0x08
    jz shift_lower
    mov bl, 1

shift_lower:
    shl dl, 1        ; Сдвиг влево
    dec cl
    jnz lower_shift

lower_done:
    test bl, bl      ; Добавляем оставшийся перенос
    jz no_final_lower
    or dl, 0x01

no_final_lower:
    and al, 0xF0     ; Собираем байт
    or al, dl
    mov bl, al       ; Обновлённый младший байт
    pop cx           ; Восстанавливаем cx

    ; Обработка старшего байта (ah)
    mov ax, si       ; Восстанавливаем исходное ax
    mov al, ah
    push cx          ; Сохраняем cx перед изменением
    mov cl, al
    shr cl, 6        ; cl = биты 6-7 (старшая тетрада)
    and cl, 0x03     ; cl = количество сдвигов (0-3)
    mov dl, al
    and dl, 0x0F     ; dl = младшая тетрада
    mov bh, 0        ; Флаг переноса

    ; Циклический сдвиг старшей тетрады
    test cl, cl
    jz upper_done

upper_shift:
    test bh, bh
    jz no_carry_upper
    or dl, 0x01      ; Добавляем перенос
    mov bh, 0

no_carry_upper:
    test dl, 0x08
    jz shift_upper
    mov bh, 1

shift_upper:
    shl dl, 1        ; Сдвиг влево
    dec cl
    jnz upper_shift

upper_done:
    test bh, bh      ; Добавляем оставшийся перенос
    jz no_final_upper
    or dl, 0x01

no_final_upper:
    and al, 0xF0     ; Собираем байт
    or al, dl
    mov bh, al       ; Обновлённый старший байт
    pop cx           ; Восстанавливаем cx

    mov ax, bx       ; Итоговый результат

    pop rsi
    pop rdx
    pop rcx
    pop rbx
    ret



    
randnum:
    rdrand rax                ; Генерируем случайное 64-битное число в rax.
    and rax, 0xffff             ; Маскируем rax, оставляя только младшие 16 бит.
    mov [result], ax            ; Сохраняем случайное 16-битное число в переменную result.
    jmp Lb1                     ; Переходим к метке Lb1 для дальнейшей обработки и вывода.

printb:
    push rbp
    mov rbp, rsp
    movzx r11d, word [result]  ; Загружаем 16-битное число
    xor rax, rax
    mov byte [len], 0          ; Сбрасываем счетчик

loop1:
    mov rcx, 1
    and rcx, r11               ; Получаем младший бит
    push rcx                   ; Сохраняем бит в стек
    inc byte [len]             ; Увеличиваем счетчик
    shr r11, 1                 ; Сдвигаем вправо
    cmp byte [len], 16         ; Проверяем, обработали ли 16 бит
    jb loop1

loop2:
    mov rdi, bin_f             ; Формат "%c"
    pop rsi                    ; Извлекаем бит
    add rsi, '0'               ; Конвертируем в ASCII
    xor rax, rax               ; Для printf
    call printf
    dec byte [len]
    jnz loop2

    ; Переход на новую строку
    mov rdi, return_button
    call printf

    leave
    ret


error_more_than_1_arg:
    mov rax, 1                  ; Устанавливаем номер системного вызова для записи.
    mov rdi, 2                  ; Устанавливаем файловый дескриптор stderr.
    mov rsi, error_msg          ; Устанавливаем указатель на сообщение об ошибке.
    mov rdx, error_msg_len      ; Устанавливаем длину сообщения об ошибке.
    syscall                     ; Выполняем системный вызов для вывода сообщения об ошибке.
    mov rax, 60                 ; Устанавливаем номер системного вызова для выхода.
    mov rdi, 1                  ; Устанавливаем код возврата ошибки.
    syscall                     ; Выполняем системный вызов для выхода.

is_digit:
    xor rax, rax                ; Обнуляем rax (предполагаем, что строка - число).
.check_loop:
    mov bl, [rsi]               ; Загружаем текущий символ из строки в bl.
    cmp bl, 0                   ; Проверяем, не конец ли строки.
    je .done                    ; Если конец строки, переходим к метке .done.
    cmp bl, '0'                 ; Проверяем, не меньше ли текущий символ '0'.
    jl .not_digit               ; Если меньше, это не цифра, переходим к метке .not_digit.
    cmp bl, '9'                 ; Проверяем, не больше ли текущий символ '9'.
    jg .not_digit               ; Если больше, это не цифра, переходим к метке .not_digit.
    inc rsi                     ; Переходим к следующему символу в строке.
    jmp .check_loop             ; Возвращаемся к началу цикла.
.not_digit:
    mov rax, 1                  ; Устанавливаем rax в 1, сигнализируя, что строка не является числом.
    ret                         ; Возврат из функции.
.done:
    ret                         ; Возврат из функции (rax останется 0).
error_not_a_digit_arg:
    mov rax, 1                  ; Устанавливаем номер системного вызова для записи.
    mov rdi, 2                  ; Устанавливаем файловый дескриптор stderr.
    mov rsi, error_not_digit    ; Устанавливаем указатель на сообщение об ошибке.
    mov rdx, error_not_digit_len ; Устанавливаем длину сообщения об ошибке.
    syscall                     ; Выполняем системный вызов для вывода сообщения об ошибке.
    mov rax, 60                 ; Устанавливаем номер системного вызова для выхода.
    mov rdi, 1                  ; Устанавливаем код возврата ошибки.
    syscall                     ; Выполняем системный вызов для выхода.

is_correct_range:
    xor rax, rax                ; Обнуляем rax (здесь будет храниться число).
    mov rbx, 10                 ; Устанавливаем основание системы счисления (10).
    xor rcx, rcx                ; Обнуляем rcx (временный регистр для цифры).
.convert_loop:
    mov cl, [rsi]               ; Загружаем текущий символ из строки в cl.
    cmp cl, 0                   ; Проверяем, не конец ли строки.
    je .conversion_done         ; Если конец строки, переходим к метке .conversion_done.
    sub cl, '0'                 ; Преобразуем символ в цифру.
    movzx rcx, cl               ; Расширяем cl до 64-бит в rcx без знака.
    mul rbx                     ; Умножаем текущее значение rax на 10.
    jo .out_of_range            ; Если произошло переполнение (число слишком большое), переходим к метке .out_of_range.
    add rax, rcx                ; Добавляем текущую цифру к числу в rax.
    cmp rax, 65535              ; Проверяем, не превышает ли число максимальное значение для 16-битного беззнакового числа.
    jg .out_of_range            ; Если превышает, переходим к метке .out_of_range.
    inc rsi                     ; Переходим к следующему символу в строке.
    jmp .convert_loop             ; Возвращаемся к началу цикла.
.conversion_done:
    xor rax, rax                ; Устанавливаем rax в 0, сигнализируя, что число в диапазоне.
    jmp .done_range            ; Переходим к метке .done_range.
.out_of_range:
    mov rax, 1                  ; Устанавливаем rax в 1, сигнализируя, что число вне диапазона.
.done_range:
    ret                         ; Возврат из функции.
error_out_of_range_arg:
    mov rdi, error_out_of_range ; Загружаем адрес сообщения об ошибке.
    call printf                 ; Выводим сообщение об ошибке.
    mov rax, 60                 ; Устанавливаем номер системного вызова для выхода.
    mov rdi, 1                  ; Устанавливаем код возврата ошибки.
    syscall                     ; Выполняем системный вызов для выхода.